//******************************************************************************
// Секция include: здесь подключается заголовочный файл к модулю
//******************************************************************************
#include "rxssb.h" // Включаем файл заголовка для нашего модуля
//******************************************************************************
// Секция определения переменных, используемых в модуле
//******************************************************************************
//------------------------------------------------------------------------------
// Глобальные
//------------------------------------------------------------------------------
//char GlobalVar1;
//char GlobalVar2;
//...
//------------------------------------------------------------------------------
// Локальные
//------------------------------------------------------------------------------
//static char LocalVar1;
//static char LocalVar2;
//...
//******************************************************************************
// Секция прототипов локальных функций
//******************************************************************************
//void local_func1 (void);
//void local_func2 (void);
//...
//******************************************************************************
// Секция описания функций (сначала глобальных, потом локальных)
//******************************************************************************


//******************************************************************************
//   Приемник SSB
//******************************************************************************
bool rx_ssb (RXSSB_t *Ch){

  dds16(&Ch->DDS_Carrier);                                                              // Генерируем два отсчета I и Q

  Ch->Filter_30_I[Ch->Filter_30_idx + 24] = Ch->DDS_Carrier.I * Ch->In * 15;        // Первый смеситель. Домножение - компенсация потерь в дециматоре
  Ch->Filter_30_Q[Ch->Filter_30_idx + 24] = Ch->DDS_Carrier.Q * Ch->In * 15;
//  
//  Ch->Out = R.Buf_48k_Out[R.Buf_LPF_48k_idx];                               // Выходной отсчет из буфера интерполятора
//  //============================================================================
  
  
  // Домен 8 кГц
  if(++(Ch->Filter_30_idx) == 6) {                                              // Если не накопилось 6 отсчетов - сразу на выход
  Ch->Filter_30_idx = 0;                                                        // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

//  R.Buf_LPF_8k_I[127] = LPF_72 (R.Buf_LPF_48k_I, LPF72_coeff_Decimation);       // Фильтр дециматор в конец поворачивающего фильтра
//  R.Buf_LPF_8k_Q[127] = LPF_72 (R.Buf_LPF_48k_Q, LPF72_coeff_Decimation);
//  shift_buf_72_6 (R.Buf_LPF_48k_I);                                             // Сдвиг буфера дециматора на 6 - подготовка к новому циклу
//  shift_buf_72_6 (R.Buf_LPF_48k_Q);
//  
//  
//  R.TmpI = LPF_128_SIN (R.Buf_LPF_8k_I, LPF128_coeff_FOS);                      // Применяем поворачивающий фильтр основной селекции
//  R.TmpQ = LPF_128_COS (R.Buf_LPF_8k_Q, LPF128_coeff_FOS);
//  shift_buf_128(R.Buf_LPF_8k_I);                                                // Сдвигаем буфера - готовим к новому циклу
//  shift_buf_128(R.Buf_LPF_8k_Q);
//  
//  
//  if (R.USB_On) R.Buf_BPF_8k[127] = (R.TmpI - R.TmpQ) ;                         // Формируем выходной USB низкочастотный сигнал в последний элемент буфера полосового филльтра
//  else R.Buf_BPF_8k[127] = (R.TmpI + R.TmpQ) ;                                  // LSB
//  
//  switch (R.RXBW){                                                              // Применяем полосовой фильтр и укладываем в интерполятор новый отсчет
//  case RXBW_NARROW:                                                     
//    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF_Tone_N);   // Узкая полоса 400 Гц
//    break;
//  case RXBW_MEDIUM:
//    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF_Tone_M);   // Средняя пооса 1 кГц
//    break;
//  case RXBW_WIDE:
//    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
//    break;
//  default:
//    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
//  }
//  
//   
//  shift_buf_128(R.Buf_BPF_8k);                                                  // Сдвиг буфера полосового фильтра
//  
//  
//  filter_interpolator_x6 (R.Buf_48k_Out_Work, LPF72_coeff_Interpolation, R.Buf_48k_Out); // Применяем интерполятор.
//  shift_buf (R.Buf_48k_Out_Work, 12);                                           // Сдвиг буфера интерполятора на 1 отсчет
//  //============================================================================
//
//
//  shift_buf_128(R.GA_Buf_BPF_8k);                                               // Сдвиг буфера полосового фильтра
//  
//
//  
//  filter_interpolator_x6 (R.GA_Buf_48k_Out_Work, LPF72_coeff_Interpolation, R.GA_Buf_48k_Out); // Применяем интерполятор.
//  shift_buf (R.GA_Buf_48k_Out_Work, 12);                                        // Сдвиг буфера интерполятора на 1 отсчет
//  //============================================================================
//
//
//  
  }//===   Конец домена 8 кГц   ================================================
//   
//  
//  if (R.RXBW == RXBW_BYPASS) R.SSB_Out_F = In;
//
//            //__LED2_OFF;
//
//            
////#define SILENCE         0
////#define MA              1
////#define GA              2
////#define MAGA            3 
//
//  return create_RX_out (R.RX_Active_Channel, R.SSB_Out_F, R.GA_SSB_Out_F);


}
//******************************************************************************
// ENF OF FILE
//******************************************************************************